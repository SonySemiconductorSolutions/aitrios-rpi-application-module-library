"use strict";(self.webpackChunkmodlib_docs=self.webpackChunkmodlib_docs||[]).push([[6571],{1776:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"motivation","title":"Motivation","description":"Purpose","source":"@site/_docs_versioned_docs/version-1.1.0/motivation.md","sourceDirName":".","slug":"/motivation","permalink":"/en/application-module-library/docs/motivation","draft":false,"unlisted":false,"tags":[],"version":"1.1.0","lastUpdatedAt":1749815802000,"sidebarPosition":1,"frontMatter":{"title":"Motivation","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Intro","permalink":"/en/application-module-library/docs/"},"next":{"title":"Getting Started","permalink":"/en/application-module-library/docs/category/getting-started"}}');var i=o(4848),r=o(8453);const s={title:"Motivation",sidebar_position:1},a="Why modlib?",l={},d=[{value:"Purpose",id:"purpose",level:2},{value:"Modularity",id:"modularity",level:2},{value:"Tooling",id:"tooling",level:2}];function c(e){const t={blockquote:"blockquote",br:"br",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"why-modlib",children:"Why modlib?"})}),"\n",(0,i.jsx)(t.h2,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsxs)(t.p,{children:["The Application Module Library (modlib) is an SDK designed for creating ",(0,i.jsx)(t.strong,{children:"end-to-end IMX500 application\u200b"}),". It aims to meet the expectations of ",(0,i.jsx)(t.strong,{children:"a large and diverse group of users, each with different objectives and expectations"}),". The library provides abstractions for specific parts of the development process, allowing users to ",(0,i.jsx)(t.strong,{children:"focus"})," on their particular areas of interest. The intuitive Python interface enables developers to streamline their workflow and concentrate on the aspects most relevant to their projects."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"It aims to provide this by being:"}),"\n",(0,i.jsxs)(t.p,{children:["\ud83d\udc8e ",(0,i.jsx)(t.strong,{children:"All in one"}),": Provides integration with all AITRIOS tools (Converter, Packager, Brain Builder, etc.) into one environment.",(0,i.jsx)(t.br,{}),"\n","\ud83d\udce6 ",(0,i.jsx)(t.strong,{children:"Scalable"}),": The modular design of the library allows easy to add new IMX500 devices, new AI models and Apps.",(0,i.jsx)(t.br,{}),"\n","\u23f1\ufe0f ",(0,i.jsx)(t.strong,{children:"Intuitive & Fast & Compact"}),": Reduce development time by providing templates for Python users to create E2E solution.\u200b In only a couple of minutes!\u200b"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"modularity",children:"Modularity"}),"\n",(0,i.jsxs)(t.p,{children:["The Application Module Library consists of 3 core components that are fully ",(0,i.jsx)(t.strong,{children:"INDEPENDENT"})," and agnostic of \u200b\neach other existence:\u200b"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)("span",{style:{color:"var(--orange)",fontWeight:"bold"},children:"Devices"}),": Any IMX500 powered device can be onboarded and used with for application development.\n\u200b"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)("span",{style:{color:"var(--orange)",fontWeight:"bold"},children:"Models"}),": Pytorch and Keras models can be ",(0,i.jsx)(t.strong,{children:"converted, packaged & deployed"})," to any device. \u200b\nChoose a ",(0,i.jsx)(t.strong,{children:"post-processor"})," function provided or develop your own post-processing function by converting the output tensor to a ",(0,i.jsx)(t.strong,{children:"predefined detection format"}),". \u200b\n\u200b"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)("span",{style:{color:"var(--orange)",fontWeight:"bold"},children:"Apps"}),": After choosing what model on which device. Enjoy a set of prebuilt, modular application components that supports the developer in solving his use-case. (e.g. annotators, tracker, heatmap \u2026 )"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Modularity",src:o(4001).A+"",width:"1569",height:"533"})}),"\n",(0,i.jsx)(t.h2,{id:"tooling",children:"Tooling"}),"\n",(0,i.jsx)(t.p,{children:"Thanks to its device abstraction layer, the Application Module Library can serve as a foundation for low-code UI/UX tools. This feature ensures that tools built on modlib are not restricted to specific devices, but are compatible with any device supported by the library."}),"\n",(0,i.jsx)(t.p,{children:"Moreover, these tools can immediately leverage new functionalities as they are added to the Application Module Library, ensuring they remain cutting-edge without the need for extensive frontend redevelopment. Simulatneously, the Application Module Library keeps supporting developers in creating end-to-end solutions with its straightforward Python API, making it accessible for a wide range of use cases."}),"\n",(0,i.jsx)(t.p,{children:"The modular architecture of modlib also acts as a safeguard against future changes. Products that integrate the Application Module Library at their core are inherently protected from changes in devices, models, or applications to other already existing features."})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},4001:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/modlib-modularity-e3b2534557b159b060d54ed0ef5da0bc.png"},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>a});var n=o(6540);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);